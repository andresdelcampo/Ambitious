/*****************************************************************************
 MODULO: undoc
 DESCRIPCION: Funciones indocumentadas de pidgen.dll
*****************************************************************************/

#include "stdafx.h"
#include "undoc.h"
#include <stdlib.h>

#define ROL _lrotl
#define ROR _lrotr


/*****************************************************************************
FUNCION: Monstruo2
PARAMETROS:
    res = estado que será modificado (4 enteros)
    mem = 16 enteros con dato origen (sólo se lee)
*****************************************************************************/
void Monstruo2(DWORD *res, DWORD *mem)
{
    register unsigned int _0_, _1_, _2_, _3_;

/*    ebx = res[0];
    edx = res[1];
    esi = res[2];
    edi = res[3];
    ebx += ((edi ^ esi) & edx) ^ edi + mem[0]
    ebx = ROL(ebx, 3)
    edi += ((esi ^ edx) & ebx) ^ esi + mem[1]
    edi = ROL(edi, 7)
    esi += ((edx ^ ebx) & edi) ^ edx + mem[2]
    esi = ROL(esi, B)
    edx += ((edi ^ ebx) & esi) ^ ebx + mem[3]
    edx = ROL(edx, 13)
*/
    /* ebx=_0_, edx=_1_, esi=_2_, edi=_3_ */

    /* Se prepara... */
    _0_ = res[0];
    _1_ = res[1];
    _2_ = res[2];
    _3_ = res[3];


    /*** Fase A ***/

    _0_ += mem[0] + (((_3_ ^ _2_) & _1_) ^ _3_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[1] + (((_2_ ^ _1_) & _0_) ^ _2_);
    _3_ = ROL(_3_, 0x07);

    _2_ += mem[2] + (((_1_ ^ _0_) & _3_) ^ _1_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[3] + (((_0_ ^ _3_) & _2_) ^ _0_);
    _1_ = ROL(_1_, 0x13);

    _0_ += mem[4] + (((_3_ ^ _2_) & _1_) ^ _3_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[5] + (((_2_ ^ _1_) & _0_) ^ _2_);
    _3_ = ROL(_3_, 0x07);

    _2_ += mem[6] + (((_1_ ^ _0_) & _3_) ^ _1_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[7] + (((_0_ ^ _3_) & _2_) ^ _0_);
    _1_ = ROL(_1_, 0x13);

    _0_ += mem[8] + (((_3_ ^ _2_) & _1_) ^ _3_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[9] + (((_2_ ^ _1_) & _0_) ^ _2_);
    _3_ = ROL(_3_, 0x07);

    _2_ += mem[10] + (((_1_ ^ _0_) & _3_) ^ _1_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[11] + (((_0_ ^ _3_) & _2_) ^ _0_);
    _1_ = ROL(_1_, 0x13);

    _0_ += mem[12] + (((_3_ ^ _2_) & _1_) ^ _3_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[13] + (((_2_ ^ _1_) & _0_) ^ _2_);
    _3_ = ROL(_3_, 0x07);

    _2_ += mem[14] + (((_1_ ^ _0_) & _3_) ^ _1_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[15] + (((_0_ ^ _3_) & _2_) ^ _0_);
    _1_ = ROL(_1_, 0x13);


    /*** Fase B ***/

    _0_ += mem[0] + 0x5A827999 + (((_2_ | _1_) & _3_) | (_2_ & _1_));
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[4] + 0x5A827999 + (((_1_ | _0_) & _2_) | (_1_ & _0_));
    _3_ = ROL(_3_, 0x05);

    _2_ += mem[8] + 0x5A827999 + (((_0_ | _3_) & _1_) | (_0_ & _3_));
    _2_ = ROL(_2_, 0x09);

    _1_ += mem[12] + 0x5A827999 + (((_3_ | _2_) & _0_) | (_3_ & _2_));
    _1_ = ROL(_1_, 0x0D);

    _0_ += mem[1] + 0x5A827999 + (((_2_ | _1_) & _3_) | (_2_ & _1_));
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[5] + 0x5A827999 + (((_1_ | _0_) & _2_) | (_1_ & _0_));
    _3_ = ROL(_3_, 0x05);

    _2_ += mem[9] + 0x5A827999 + (((_0_ | _3_) & _1_) | (_0_ & _3_));
    _2_ = ROL(_2_, 0x09);

    _1_ += mem[13] + 0x5A827999 + (((_3_ | _2_) & _0_) | (_3_ & _2_));
    _1_ = ROL(_1_, 0x0D);

    _0_ += mem[2] + 0x5A827999 + (((_2_ | _1_) & _3_) | (_2_ & _1_));
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[6] + 0x5A827999 + (((_1_ | _0_) & _2_) | (_1_ & _0_));
    _3_ = ROL(_3_, 0x05);

    _2_ += mem[10] + 0x5A827999 + (((_0_ | _3_) & _1_) | (_0_ & _3_));
    _2_ = ROL(_2_, 0x09);

    _1_ += mem[14] + 0x5A827999 + (((_3_ | _2_) & _0_) | (_3_ & _2_));
    _1_ = ROL(_1_, 0x0D);

    _0_ += mem[3] + 0x5A827999 + (((_2_ | _1_) & _3_) | (_2_ & _1_));
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[7] + 0x5A827999 + (((_1_ | _0_) & _2_) | (_1_ & _0_));
    _3_ = ROL(_3_, 0x05);

    _2_ += mem[11] + 0x5A827999 + (((_0_ | _3_) & _1_) | (_0_ & _3_));
    _2_ = ROL(_2_, 0x09);

    _1_ += mem[15] + 0x5A827999 + (((_3_ | _2_) & _0_) | (_3_ & _2_));
    _1_ = ROL(_1_, 0x0D);


    /*** Fase C ***/

    _0_ += mem[0] + 0x6ED9EBA1 + (_3_ ^ _2_ ^ _1_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[8] + 0x6ED9EBA1 + (_2_ ^ _1_ ^ _0_);
    _3_ = ROL(_3_, 0x09);

    _2_ += mem[4] + 0x6ED9EBA1 + (_1_ ^ _0_ ^ _3_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[12] + 0x6ED9EBA1 + (_0_ ^ _3_ ^ _2_);
    _1_ = ROL(_1_, 0x0F);

    _0_ += mem[2] + 0x6ED9EBA1 + (_3_ ^ _2_ ^ _1_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[10] + 0x6ED9EBA1 + (_2_ ^ _1_ ^ _0_);
    _3_ = ROL(_3_, 0x09);

    _2_ += mem[6] + 0x6ED9EBA1 + (_1_ ^ _0_ ^ _3_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[14] + 0x6ED9EBA1 + (_0_ ^ _3_ ^ _2_);
    _1_ = ROL(_1_, 0x0F);

    _0_ += mem[1] + 0x6ED9EBA1 + (_3_ ^ _2_ ^ _1_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[9] + 0x6ED9EBA1 + (_2_ ^ _1_ ^ _0_);
    _3_ = ROL(_3_, 0x09);

    _2_ += mem[5] + 0x6ED9EBA1 + (_1_ ^ _0_ ^ _3_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[13] + 0x6ED9EBA1 + (_0_ ^ _3_ ^ _2_);
    _1_ = ROL(_1_, 0x0F);

    _0_ += mem[3] + 0x6ED9EBA1 + (_3_ ^ _2_ ^ _1_);
    _0_ = ROL(_0_, 0x03);

    _3_ += mem[11] + 0x6ED9EBA1 + (_2_ ^ _1_ ^ _0_);
    _3_ = ROL(_3_, 0x09);

    _2_ += mem[7] + 0x6ED9EBA1 + (_1_ ^ _0_ ^ _3_);
    _2_ = ROL(_2_, 0x0B);

    _1_ += mem[15] + 0x6ED9EBA1 + (_0_ ^ _3_ ^ _2_);
    _1_ = ROL(_1_, 0x0F);


    /* Finaliza */
    res[0] += _0_;
    res[1] += _1_;
    res[2] += _2_;
    res[3] += _3_;
}


/*****************************************************************************
FUNCION: Generador
DESCRIPCION:
*****************************************************************************/
void Generador(BYTE *tabla, BYTE *llave, int longllave)
{
    unsigned char bl = 0, dl;
    int i,j;

    // Genera tabla original
    for(i=0x00; i<=0xFF; i++)
        tabla[i] = i;
    // A 0 las variables especiales de lugar y suma
    tabla[0x100] = 0;
    tabla[0x101] = 0;

    for(i=0, j=0; i<256; i++, j++)
    {
        if(j==longllave)
            j=0;
        dl = tabla[i];
        bl += dl + llave[j];
        tabla[i] = tabla[bl];
        tabla[bl] = dl;
    };
}


/*****************************************************************************
FUNCION: Modificador
DESCRIPCION:
*****************************************************************************/
void Modificador(BYTE *tabla, BYTE *llave, int longllave)
{
    unsigned char al, bl, cl, dl;
    int i;

    cl = tabla[0x100];
    dl = tabla[0x101];

    for(i=0; i<longllave; i++)
    {
        // Mantiene i de 0 a 255
        cl++;
        al = tabla[cl];
        dl += al;
        bl = tabla[dl];
        tabla[cl] = bl;
        tabla[dl] = al;
        al += bl;
        al = tabla[al];
        llave[i] = llave[i] ^ al;
    }

    tabla[0x100] = cl;
    tabla[0x101] = dl;
}


